#include "level.h"

#include <iostream>
#include <fstream>

#include <datamanager/data.h>
#include <models/models.h>
#include <textures/materiallibrary.h>
#include <game/entities/baseentity.h>

void CLevel::ReadInfoFromData(const CData* pData)
{
	for (size_t i = 0; i < pData->GetNumChildren(); i++)
	{
		CData* pChildData = pData->GetChild(i);

		OnReadInfo(pChildData);
	}
}

void CLevel::OnReadInfo(const CData* pData)
{
	if (pData->GetKey() == "Name")
		m_sName = pData->GetValueString();
	else if (pData->GetKey() == "GameMode")
		m_sGameMode = pData->GetValueString();
}

void CLevel::SaveToFile()
{
	if (!m_sFile.length())
	{
		TAssert(m_sFile.length());
		TError("Can't find level file \'" + m_sFile + "\' to save.\n");
		return;
	}

	std::basic_ofstream<tchar> f(m_sFile.c_str());

	tstring sMessage = "// Generated by the Tinker Engine\n// Feel free to modify\n\n";
	f.write(sMessage.data(), sMessage.length());

	tstring sName = "Name: " + m_sName + "\n";
	f.write(sName.data(), sName.length());

	tstring sGameMode = "GameMode: " + m_sGameMode + "\n\n";
	f.write(sGameMode.data(), sGameMode.length());

	for (size_t i = 0; i < m_aLevelEntities.size(); i++)
	{
		auto pEntity = &m_aLevelEntities[i];

		tstring sEntity = "Entity: " + pEntity->GetClass() + "\n{\n";
		f.write(sEntity.data(), sEntity.length());

		if (pEntity->GetName().length())
		{
			tstring sName = "\tName: " + pEntity->GetName() + "\n";
			f.write(sName.data(), sName.length());
		}

		for (auto it = pEntity->GetParameters().begin(); it != pEntity->GetParameters().end(); it++)
		{
			if (it->first == "Name")
				continue;

			tstring sName = "\t" + it->first + ": " + it->second + "\n";
			f.write(sName.data(), sName.length());
		}

		for (size_t j = 0; j < pEntity->GetOutputs().size(); j++)
		{
			auto pOutput = &pEntity->GetOutputs()[j];
			tstring sOutput = "\n\tOutput: " + pOutput->m_sOutput + "\n\t{\n";
			f.write(sOutput.data(), sOutput.length());

			if (pOutput->m_sTargetName.length())
			{
				tstring sTarget = "\t\tTarget: " + pOutput->m_sTargetName + "\n";
				f.write(sTarget.data(), sTarget.length());
			}

			if (pOutput->m_sInput.length())
			{
				tstring sInput = "\t\tInput: " + pOutput->m_sInput + "\n";
				f.write(sInput.data(), sInput.length());
			}

			if (pOutput->m_sArgs.length())
			{
				tstring sArgs = "\t\tArgs: " + pOutput->m_sArgs + "\n";
				f.write(sArgs.data(), sArgs.length());
			}

			if (pOutput->m_bKill)
			{
				tstring sKill = "\t\tKill: yes\n";
				f.write(sKill.data(), sKill.length());
			}

			tstring sClose = "\t}\n";
			f.write(sClose.data(), sClose.length());
		}

		tstring sClose = "}\n\n";
		f.write(sClose.data(), sClose.length());
	}

	TMsg("Wrote level file '" + m_sFile + "'\n");
}

void CLevel::CreateEntitiesFromData(const CData* pData)
{
	m_aLevelEntities.clear();
	m_iNextHandle = 0;

	for (size_t i = 0; i < pData->GetNumChildren(); i++)
	{
		CData* pChildData = pData->GetChild(i);

		if (pChildData->GetKey() != "Entity")
			continue;

		m_aLevelEntities.push_back(CLevelEntity(m_iNextHandle++, pChildData->GetValueString()));

		CLevelEntity* pEntity = &m_aLevelEntities.back();

		pEntity->m_iHandle = m_aLevelEntities.size()-1;

		for (size_t k = 0; k < pChildData->GetNumChildren(); k++)
		{
			CData* pField = pChildData->GetChild(k);

			tstring sHandle = pField->GetKey();
			tstring sValue = pField->GetValueString();

			if (sHandle == "Output")
			{
				tstring sTarget;
				tstring sInput;
				tstring sArgs;
				bool bKill = false;

				for (size_t o = 0; o < pField->GetNumChildren(); o++)
				{
					CData* pOutputData = pField->GetChild(o);

					if (pOutputData->GetKey() == "Target")
						sTarget = pOutputData->GetValueString();
					else if (pOutputData->GetKey() == "Input")
						sInput = pOutputData->GetValueString();
					else if (pOutputData->GetKey() == "Args")
						sArgs = pOutputData->GetValueString();
					else if (pOutputData->GetKey() == "Kill")
						bKill = pOutputData->GetValueBool();
				}

				CLevelEntity::CLevelEntityOutput& oOutput = pEntity->GetOutputs().push_back();
				oOutput.m_sOutput = sValue;
				oOutput.m_sTargetName = sTarget;
				oOutput.m_sInput = sInput;
				oOutput.m_sArgs = sArgs;
				oOutput.m_bKill = bKill;
			}
			else
			{
				pEntity->SetParameterValue(sHandle, sValue);
			}
		}
	}
}

size_t CLevel::CreateEntity(const tstring& sClassName)
{
	m_aLevelEntities.push_back(CLevelEntity(m_iNextHandle++, sClassName));

	return m_aLevelEntities.size()-1;
}

size_t CLevel::CopyEntity(const CLevelEntity& oOther)
{
	m_aLevelEntities.push_back(CLevelEntity(oOther));   // Force it to use the move constructor.

	m_aLevelEntities.back().m_iHandle = m_iNextHandle++;

	return m_aLevelEntities.size()-1;
}

const tstring& CLevelEntity::GetParameterValue(const tstring& sKey) const
{
	const auto it = m_asParameters.find(sKey);
	if (it == m_asParameters.end())
	{
		static tstring sEmpty = "";
		return sEmpty;
	}

	return it->second;
}

void CLevelEntity::SetParameterValue(const tstring& sKey, const tstring& sValue)
{
	auto it = m_asParameters.find(sKey);
	if (it == m_asParameters.end())
	{
		if (!sValue.length())
			return;

		m_asParameters[sKey] = sValue;
	}
	else
	{
		if (!sValue.length())
		{
			m_asParameters.erase(sKey);
			Dirtify();
			return;
		}

		tstring& sCurrentValue = it->second;
		if (sCurrentValue == sValue)
			return;

		sCurrentValue = sValue;
	}

	Dirtify();

	CSaveData oSaveData;
	CSaveData* pSaveData = CBaseEntity::FindSaveDataValuesByHandle(("C" + GetClass()).c_str(), sKey.c_str(), &oSaveData);

	if (!pSaveData)
		TMsg("Level entity " + GetClass() + ":" + GetName() + " has unregistered savedata value: " + sKey + "\n");

	if (pSaveData && pSaveData->m_pszHandle && pSaveData->m_bDefault)
	{
		// Special case.
		if (strcmp(pSaveData->m_pszHandle, "Model") == 0)
		{
			m_hMaterialModel = CMaterialLibrary::AddMaterial(sValue);

			// Don't continue to erasing the default parameters if it's a model, since models have special processing.
			return;
		}

		if (strcmp(pSaveData->m_pszType, "bool") == 0)
		{
			bool bValue = UnserializeString_bool(sValue);

			bool b = *((bool*)&pSaveData->m_oDefault[0]);
			if (bValue == b)
				m_asParameters.erase(sKey);
		}
		else
		{
			if (strcmp(pSaveData->m_pszType, "size_t") == 0)
			{
				size_t i = *((size_t*)&pSaveData->m_oDefault[0]);
				if (stoi(sValue) == i)
					m_asParameters.erase(sKey);
			}
			else if (strcmp(pSaveData->m_pszType, "float") == 0)
			{
				float f = *((float*)&pSaveData->m_oDefault[0]);
				if (stof(sValue) == f)
					m_asParameters.erase(sKey);
			}
			else if (strcmp(pSaveData->m_pszType, "Vector") == 0)
			{
				if (CanUnserializeString_TVector(sValue))
				{
					Vector v = *((Vector*)&pSaveData->m_oDefault[0]);
					if (UnserializeString_TVector(sValue) == v)
						m_asParameters.erase(sKey);
				}
			}
			else if (strcmp(pSaveData->m_pszType, "Vector2D") == 0)
			{
				if (CanUnserializeString_Vector2D(sValue))
				{
					Vector2D v = *((Vector2D*)&pSaveData->m_oDefault[0]);
					if (UnserializeString_Vector2D(sValue) == v)
						m_asParameters.erase(sKey);
				}
			}
			else if (strcmp(pSaveData->m_pszType, "EAngle") == 0)
			{
				if (CanUnserializeString_EAngle(sValue))
				{
					EAngle v = *((EAngle*)&pSaveData->m_oDefault[0]);
					if (UnserializeString_EAngle(sValue) == v)
						m_asParameters.erase(sKey);
				}
			}
			else if (strcmp(pSaveData->m_pszType, "Matrix4x4") == 0)
			{
				if (CanUnserializeString_Matrix4x4(sValue))
				{
					Matrix4x4 m = *((Matrix4x4*)&pSaveData->m_oDefault[0]);
					if (UnserializeString_Matrix4x4(sValue) == m)
						m_asParameters.erase(sKey);
				}
			}
			else if (strcmp(pSaveData->m_pszType, "AABB") == 0)
			{
				if (CanUnserializeString_AABB(sValue))
				{
					AABB b = *((AABB*)&pSaveData->m_oDefault[0]);
					if (UnserializeString_AABB(sValue) == b)
						m_asParameters.erase(sKey);
				}
			}
			else
			{
				TUnimplemented();
			}
		}
	}
}

void CLevelEntity::RemoveParameter(const tstring& sKey)
{
	m_asParameters.erase(sKey);
	Dirtify();
}

bool CLevelEntity::HasParameterValue(const tstring& sKey) const
{
	return m_asParameters.find(sKey) != m_asParameters.end();
}

CModel* CLevelEntity::GetModel() const
{
	return CModelLibrary::GetModel(GetModelID());
}

const Matrix4x4 CLevelEntity::GetPhysicsTransform() const
{
	return GetGlobalTransform();
}

void CLevelEntity::SetPhysicsTransform(const Matrix4x4& m)
{
	SetGlobalTransform(m);
}

Matrix4x4 CLevelEntity::CalculateGlobalTransform(CLevelEntity* pThis)
{
	Matrix4x4 mLocal;

	tstring sLocalOrigin = pThis->GetParameterValue("Origin");
	if (sLocalOrigin.length() && CanUnserializeString_TVector(sLocalOrigin))
		mLocal.SetTranslation(UnserializeString_TVector(sLocalOrigin));

	tstring sLocalAngles = pThis->GetParameterValue("Angles");
	if (sLocalAngles.length() && CanUnserializeString_EAngle(sLocalAngles))
		mLocal.SetAngles(UnserializeString_EAngle(sLocalAngles));

	tstring sAABB = pThis->GetParameterValue("BoundingBox");
	if (CanUnserializeString_AABB(sAABB))
	{
		AABB aabbBounds = UnserializeString_AABB(sAABB, pThis->GetName(), pThis->m_sClass, "BoundingBox");

		// Center the entity around this bounding box.
		Vector vecGlobalOrigin = aabbBounds.Center();
		mLocal.SetTranslation(mLocal.GetTranslation() + vecGlobalOrigin);

		Vector vecNewOrigin = mLocal.GetTranslation();
		pThis->SetParameterValue("Origin", pretty_float(vecNewOrigin.x) + " " + pretty_float(vecNewOrigin.y) + " " + pretty_float(vecNewOrigin.z));

		aabbBounds.m_vecMins -= vecGlobalOrigin;
		aabbBounds.m_vecMaxs -= vecGlobalOrigin;
		pThis->SetParameterValue("BoundingBox",
			pretty_float(aabbBounds.m_vecMins.x) + " " + pretty_float(aabbBounds.m_vecMins.y) + " " + pretty_float(aabbBounds.m_vecMins.z) + " "
			+ pretty_float(aabbBounds.m_vecMaxs.x) + " " + pretty_float(aabbBounds.m_vecMaxs.y) + " " + pretty_float(aabbBounds.m_vecMaxs.z));
	}

	return mLocal;
}

TRS CLevelEntity::CalculateGlobalTRS(CLevelEntity* pThis)
{
	TRS trsLocal;

	tstring sLocalOrigin = pThis->GetParameterValue("Origin");
	if (sLocalOrigin.length() && CanUnserializeString_TVector(sLocalOrigin))
		trsLocal.m_vecTranslation = UnserializeString_TVector(sLocalOrigin);

	tstring sLocalAngles = pThis->GetParameterValue("Angles");
	if (sLocalAngles.length() && CanUnserializeString_EAngle(sLocalAngles))
		trsLocal.m_angRotation = UnserializeString_EAngle(sLocalAngles);

	tstring sScale = pThis->GetParameterValue("Scale");
	if (sScale.length() && CanUnserializeString_TVector(sScale))
		trsLocal.m_vecScaling = UnserializeString_TVector(sScale);

	tstring sAABB = pThis->GetParameterValue("BoundingBox");
	if (CanUnserializeString_AABB(sAABB))
	{
		AABB aabbBounds = UnserializeString_AABB(sAABB, pThis->GetName(), pThis->m_sClass, "BoundingBox");

		// Center the entity around this bounding box.
		trsLocal.m_vecTranslation += aabbBounds.Center();
	}

	return trsLocal;
}

bool CLevelEntity::CalculateVisible(CLevelEntity* pThis)
{
	tstring sVisible = pThis->GetParameterValue("Visible");
	if (sVisible.length() && CanUnserializeString_bool(sVisible))
		return UnserializeString_bool(sVisible);

	CSaveData oDefault;
	CBaseEntity::FindSaveDataValuesByHandle(("C" + pThis->m_sClass).c_str(), "Visible", &oDefault);
	return *((bool*)&oDefault.m_oDefault);
}

bool CLevelEntity::CalculateRenderInverted(CLevelEntity* pThis)
{
	tstring sRenderInverted = pThis->GetParameterValue("RenderInverted");
	if (sRenderInverted.length() && CanUnserializeString_bool(sRenderInverted))
		return UnserializeString_bool(sRenderInverted);

	return *((bool*)&CBaseEntity::FindSaveDataByHandle(("C" + pThis->m_sClass).c_str(), "RenderInverted")->m_oDefault);
}

bool CLevelEntity::CalculateDisableBackCulling(CLevelEntity* pThis)
{
	tstring sDisableBackCulling = pThis->GetParameterValue("DisableBackCulling");
	if (sDisableBackCulling.length() && CanUnserializeString_bool(sDisableBackCulling))
		return UnserializeString_bool(sDisableBackCulling);

	return *((bool*)&CBaseEntity::FindSaveDataByHandle(("C" + pThis->m_sClass).c_str(), "DisableBackCulling")->m_oDefault);
}

size_t CLevelEntity::CalculateModelID(CLevelEntity* pThis)
{
	tstring sModel = pThis->GetParameterValue("Model");
	size_t iModel = CModelLibrary::FindModel(sModel);

	if (iModel != ~0)
		return iModel;

	iModel = CModelLibrary::AddModel(sModel);

	if (iModel != ~0)
		return iModel;

	CSaveData* pSaveData = CBaseEntity::FindSaveDataByHandle(("C" + pThis->m_sClass).c_str(), "Model");
	TAssert(pSaveData);
	if (!pSaveData)
		return ~0;

	if (pSaveData->m_bDefault)
		return CModelLibrary::FindModel(pSaveData->m_oDefault);

	return ~0;
}

Vector CLevelEntity::CalculateScale(CLevelEntity* pThis)
{
	tstring sScale = pThis->GetParameterValue("Scale");

	if (CanUnserializeString_TVector(sScale))
		return UnserializeString_TVector(sScale);

	return *((Vector*)&CBaseEntity::FindSaveDataByHandle(("C" + pThis->m_sClass).c_str(), "Scale")->m_oDefault);
}

AABB CLevelEntity::CalculateBoundingBox(CLevelEntity* pThis)
{
	size_t iModel = pThis->GetModelID();
	CModel* pModel = CModelLibrary::GetModel(iModel);

	if (pModel)
		return pModel->m_aabbVisBoundingBox;

	tstring sAABB = pThis->GetParameterValue("BoundingBox");

	AABB aabbBounds = AABB(Vector(-0.5f, -0.5f, -0.5f), Vector(0.5f, 0.5f, 0.5f));

	if (CanUnserializeString_AABB(sAABB))
	{
		aabbBounds = UnserializeString_AABB(sAABB, pThis->GetName(), pThis->m_sClass, "BoundingBox");

		// Center the entity around this bounding box.
		Vector vecGlobalOrigin = aabbBounds.Center();
		aabbBounds.m_vecMins -= vecGlobalOrigin;
		aabbBounds.m_vecMaxs -= vecGlobalOrigin;
	}
	else
	{
		CSaveData* pSaveData = CBaseEntity::FindSaveDataByHandle(tstring("C"+pThis->m_sClass).c_str(), "BoundingBox");
		if (pSaveData && pSaveData->m_bDefault)
			memcpy(&aabbBounds, &pSaveData->m_oDefault, sizeof(aabbBounds));
	}

	if (pThis->m_hMaterialModel.IsValid() && pThis->m_hMaterialModel->m_ahTextures.size())
	{
		CTextureHandle hBaseTexture = pThis->m_hMaterialModel->m_ahTextures[0];

		if (hBaseTexture.IsValid())
		{
			aabbBounds.m_vecMaxs.y *= (float)hBaseTexture->m_iHeight/pThis->m_hMaterialModel->m_iTexelsPerMeter;
			aabbBounds.m_vecMins.y *= (float)hBaseTexture->m_iHeight/pThis->m_hMaterialModel->m_iTexelsPerMeter;

			aabbBounds.m_vecMaxs.z *= (float)hBaseTexture->m_iWidth/pThis->m_hMaterialModel->m_iTexelsPerMeter;
			aabbBounds.m_vecMins.z *= (float)hBaseTexture->m_iWidth/pThis->m_hMaterialModel->m_iTexelsPerMeter;
		}
	}

	aabbBounds.m_vecMins = aabbBounds.m_vecMins * pThis->GetScale();
	aabbBounds.m_vecMaxs = aabbBounds.m_vecMaxs * pThis->GetScale();

	return aabbBounds;
}

tstring CLevelEntity::CalculateName(CLevelEntity* pThis)
{
	return pThis->GetParameterValue("Name");
}
